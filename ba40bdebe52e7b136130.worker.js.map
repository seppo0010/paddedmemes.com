{"version":3,"file":"ba40bdebe52e7b136130.worker.js","mappings":"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","sources":["../node_modules/lodash.uniqby/index.js","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/minisearch/src/SearchableMap/TreeIterator.ts","../node_modules/minisearch/src/SearchableMap/fuzzySearch.ts","../node_modules/minisearch/src/SearchableMap/SearchableMap.ts","../node_modules/minisearch/src/MiniSearch.ts","search.worker.ts"],"sourcesContent":["/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity]\n *  The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length)\n    ? baseUniq(array, baseIteratee(iteratee, 2))\n    : [];\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = uniqBy;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","import type { RadixTree, Entry, LeafType } from './types'\n\n/** @ignore */\nconst ENTRIES = 'ENTRIES'\n\n/** @ignore */\nconst KEYS = 'KEYS'\n\n/** @ignore */\nconst VALUES = 'VALUES'\n\n/** @ignore */\nconst LEAF = '' as LeafType\n\ninterface Iterators<T> {\n  ENTRIES: Entry<T>\n  KEYS: string\n  VALUES: T\n}\n\ntype Kind<T> = keyof Iterators<T>\ntype Result<T, K extends keyof Iterators<T>> = Iterators<T>[K]\n\ntype IteratorPath<T> = {\n  node: RadixTree<T>,\n  keys: string[]\n}[]\n\nexport type IterableSet<T> = {\n  _tree: RadixTree<T>,\n  _prefix: string\n}\n\n/**\n * @private\n */\nclass TreeIterator<T, K extends Kind<T>> implements Iterator<Result<T, K>> {\n  set: IterableSet<T>\n  _type: K\n  _path: IteratorPath<T>\n\n  constructor (set: IterableSet<T>, type: K) {\n    const node = set._tree\n    const keys = Array.from(node.keys())\n    this.set = set\n    this._type = type\n    this._path = keys.length > 0 ? [{ node, keys }] : []\n  }\n\n  next (): IteratorResult<Result<T, K>> {\n    const value = this.dive()\n    this.backtrack()\n    return value\n  }\n\n  dive (): IteratorResult<Result<T, K>> {\n    if (this._path.length === 0) { return { done: true, value: undefined } }\n    const { node, keys } = last(this._path)!\n    if (last(keys) === LEAF) { return { done: false, value: this.result() } }\n\n    const child = node.get(last(keys)!)!\n    this._path.push({ node: child, keys: Array.from(child.keys()) })\n    return this.dive()\n  }\n\n  backtrack (): void {\n    if (this._path.length === 0) { return }\n    const keys = last(this._path)!.keys\n    keys.pop()\n    if (keys.length > 0) { return }\n    this._path.pop()\n    this.backtrack()\n  }\n\n  key (): string {\n    return this.set._prefix + this._path\n      .map(({ keys }) => last(keys))\n      .filter(key => key !== LEAF)\n      .join('')\n  }\n\n  value (): T {\n    return last(this._path)!.node.get(LEAF)!\n  }\n\n  result (): Result<T, K> {\n    switch (this._type) {\n      case VALUES: return this.value() as Result<T, K>\n      case KEYS: return this.key() as Result<T, K>\n      default: return [this.key(), this.value()] as Result<T, K>\n    }\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n}\n\nconst last = <T>(array: T[]): T | undefined => {\n  return array[array.length - 1]\n}\n\nexport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF }\n","/* eslint-disable no-labels */\nimport { LEAF } from './TreeIterator'\nimport type { RadixTree } from './types'\n\nexport type FuzzyResult<T> = [T, number]\n\nexport type FuzzyResults<T> = Map<string, FuzzyResult<T>>\n\n/**\n * @ignore\n */\nexport const fuzzySearch = <T = any>(node: RadixTree<T>, query: string, maxDistance: number): FuzzyResults<T> => {\n  const results: FuzzyResults<T> = new Map()\n  if (query === undefined) return results\n\n  // Number of columns in the Levenshtein matrix.\n  const n = query.length + 1\n\n  // Matching terms can never be longer than N + maxDistance.\n  const m = n + maxDistance\n\n  // Fill first matrix row and column with numbers: 0 1 2 3 ...\n  const matrix = new Uint8Array(m * n).fill(maxDistance + 1)\n  for (let j = 0; j < n; ++j) matrix[j] = j\n  for (let i = 1; i < m; ++i) matrix[i * n] = i\n\n  recurse(\n    node,\n    query,\n    maxDistance,\n    results,\n    matrix,\n    1,\n    n,\n    ''\n  )\n\n  return results\n}\n\n// Modified version of http://stevehanov.ca/blog/?id=114\n\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\n\nconst recurse = <T = any>(\n  node: RadixTree<T>,\n  query: string,\n  maxDistance: number,\n  results: FuzzyResults<T>,\n  matrix: Uint8Array,\n  m: number,\n  n: number,\n  prefix: string\n): void => {\n  const offset = m * n\n\n  key: for (const key of node.keys()) {\n    if (key === LEAF) {\n      // We've reached a leaf node. Check if the edit distance acceptable and\n      // store the result if it is.\n      const distance = matrix[offset - 1]\n      if (distance <= maxDistance) {\n        results.set(prefix, [node.get(key)!, distance])\n      }\n    } else {\n      // Iterate over all characters in the key. Update the Levenshtein matrix\n      // and check if the minimum distance in the last row is still within the\n      // maximum edit distance. If it is, we can recurse over all child nodes.\n      let i = m\n      for (let pos = 0; pos < key.length; ++pos, ++i) {\n        const char = key[pos]\n        const thisRowOffset = n * i\n        const prevRowOffset = thisRowOffset - n\n\n        // Set the first column based on the previous row, and initialize the\n        // minimum distance in the current row.\n        let minDistance = matrix[thisRowOffset]\n\n        const jmin = Math.max(0, i - maxDistance - 1)\n        const jmax = Math.min(n - 1, i + maxDistance)\n\n        // Iterate over remaining columns (characters in the query).\n        for (let j = jmin; j < jmax; ++j) {\n          const different = char !== query[j]\n\n          // It might make sense to only read the matrix positions used for\n          // deletion/insertion if the characters are different. But we want to\n          // avoid conditional reads for performance reasons.\n          const rpl = matrix[prevRowOffset + j] + +different\n          const del = matrix[prevRowOffset + j + 1] + 1\n          const ins = matrix[thisRowOffset + j] + 1\n\n          const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins)\n\n          if (dist < minDistance) minDistance = dist\n        }\n\n        // Because distance will never decrease, we can stop. There will be no\n        // matching child nodes.\n        if (minDistance > maxDistance) {\n          continue key\n        }\n      }\n\n      recurse(\n        node.get(key)!,\n        query,\n        maxDistance,\n        results,\n        matrix,\n        i,\n        n,\n        prefix + key\n      )\n    }\n  }\n}\n\nexport default fuzzySearch\n","/* eslint-disable no-labels */\nimport { TreeIterator, ENTRIES, KEYS, VALUES, LEAF } from './TreeIterator'\nimport fuzzySearch, { type FuzzyResults } from './fuzzySearch'\nimport type { RadixTree, Entry, Path } from './types'\n\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nexport default class SearchableMap<T = any> {\n  /**\n   * @internal\n   */\n  _tree: RadixTree<T>\n\n  /**\n   * @internal\n   */\n  _prefix: string\n\n  private _size: number | undefined = undefined\n\n  /**\n   * The constructor is normally called without arguments, creating an empty\n   * map. In order to create a {@link SearchableMap} from an iterable or from an\n   * object, check {@link SearchableMap.from} and {@link\n   * SearchableMap.fromObject}.\n   *\n   * The constructor arguments are for internal use, when creating derived\n   * mutable views of a map at a prefix.\n   */\n  constructor (tree: RadixTree<T> = new Map(), prefix = '') {\n    this._tree = tree\n    this._prefix = prefix\n  }\n\n  /**\n   * Creates and returns a mutable view of this {@link SearchableMap},\n   * containing only entries that share the given prefix.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set(\"unicorn\", 1)\n   * map.set(\"universe\", 2)\n   * map.set(\"university\", 3)\n   * map.set(\"unique\", 4)\n   * map.set(\"hello\", 5)\n   *\n   * let uni = map.atPrefix(\"uni\")\n   * uni.get(\"unique\") // => 4\n   * uni.get(\"unicorn\") // => 1\n   * uni.get(\"hello\") // => undefined\n   *\n   * let univer = map.atPrefix(\"univer\")\n   * univer.get(\"unique\") // => undefined\n   * univer.get(\"universe\") // => 2\n   * univer.get(\"university\") // => 3\n   * ```\n   *\n   * @param prefix  The prefix\n   * @return A {@link SearchableMap} representing a mutable view of the original\n   * Map at the given prefix\n   */\n  atPrefix (prefix: string): SearchableMap<T> {\n    if (!prefix.startsWith(this._prefix)) { throw new Error('Mismatched prefix') }\n\n    const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length))\n\n    if (node === undefined) {\n      const [parentNode, key] = last(path)\n\n      for (const k of parentNode!.keys()) {\n        if (k !== LEAF && k.startsWith(key)) {\n          const node = new Map()\n          node.set(k.slice(key.length), parentNode!.get(k)!)\n          return new SearchableMap(node, prefix)\n        }\n      }\n    }\n\n    return new SearchableMap<T>(node, prefix)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n   */\n  clear (): void {\n    this._size = undefined\n    this._tree.clear()\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n   * @param key  Key to delete\n   */\n  delete (key: string): void {\n    this._size = undefined\n    return remove(this._tree, key)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n   * @return An iterator iterating through `[key, value]` entries.\n   */\n  entries () {\n    return new TreeIterator(this, ENTRIES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n   * @param fn  Iteration function\n   */\n  forEach (fn: (key: string, value: T, map: SearchableMap) => void): void {\n    for (const [key, value] of this) {\n      fn(key, value, this)\n    }\n  }\n\n  /**\n   * Returns a Map of all the entries that have a key within the given edit\n   * distance from the search key. The keys of the returned Map are the matching\n   * keys, while the values are two-element arrays where the first element is\n   * the value associated to the key, and the second is the edit distance of the\n   * key to the search key.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * let map = new SearchableMap()\n   * map.set('hello', 'world')\n   * map.set('hell', 'yeah')\n   * map.set('ciao', 'mondo')\n   *\n   * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n   * map.fuzzyGet('hallo', 2)\n   * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n   *\n   * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n   * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n   * // (change \"e\" to \"a\", delete \"o\")\n   * ```\n   *\n   * @param key  The search key\n   * @param maxEditDistance  The maximum edit distance (Levenshtein)\n   * @return A Map of the matching keys to their value and edit distance\n   */\n  fuzzyGet (key: string, maxEditDistance: number): FuzzyResults<T> {\n    return fuzzySearch<T>(this._tree, key, maxEditDistance)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n   * @param key  Key to get\n   * @return Value associated to the key, or `undefined` if the key is not\n   * found.\n   */\n  get (key: string): T | undefined {\n    const node = lookup<T>(this._tree, key)\n    return node !== undefined ? node.get(LEAF) : undefined\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n   * @param key  Key\n   * @return True if the key is in the map, false otherwise\n   */\n  has (key: string): boolean {\n    const node = lookup(this._tree, key)\n    return node !== undefined && node.has(LEAF)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n   * @return An `Iterable` iterating through keys\n   */\n  keys () {\n    return new TreeIterator(this, KEYS)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n   * @param key  Key to set\n   * @param value  Value to associate to the key\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  set (key: string, value: T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, value)\n    return this\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n   */\n  get size (): number {\n    if (this._size) { return this._size }\n    /** @ignore */\n    this._size = 0\n\n    const iter = this.entries()\n    while (!iter.next().done) this._size! += 1\n\n    return this._size\n  }\n\n  /**\n   * Updates the value at the given key using the provided function. The function\n   * is called with the current value at the key, and its return value is used as\n   * the new value to be set.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Increment the current value by one\n   * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n   * ```\n   *\n   * If the value at the given key is or will be an object, it might not require\n   * re-assignment. In that case it is better to use `fetch()`, because it is\n   * faster.\n   *\n   * @param key  The key to update\n   * @param fn  The function used to compute the new value from the current one\n   * @return The {@link SearchableMap} itself, to allow chaining\n   */\n  update (key: string, fn: (value: T | undefined) => T): SearchableMap<T> {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n    node.set(LEAF, fn(node.get(LEAF)))\n    return this\n  }\n\n  /**\n   * Fetches the value of the given key. If the value does not exist, calls the\n   * given function to create a new value, which is inserted at the given key\n   * and subsequently returned.\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * const map = searchableMap.fetch('somekey', () => new Map())\n   * map.set('foo', 'bar')\n   * ```\n   *\n   * @param key  The key to update\n   * @param initial  A function that creates a new value if the key does not exist\n   * @return The existing or new value at the given key\n   */\n  fetch (key: string, initial: () => T): T {\n    if (typeof key !== 'string') { throw new Error('key must be a string') }\n    this._size = undefined\n    const node = createPath(this._tree, key)\n\n    let value = node.get(LEAF)\n    if (value === undefined) {\n      node.set(LEAF, value = initial())\n    }\n\n    return value\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n   * @return An `Iterable` iterating through values.\n   */\n  values () {\n    return new TreeIterator(this, VALUES)\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from an `Iterable` of entries\n   *\n   * @param entries  Entries to be inserted in the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static from<T = any> (entries: Iterable<Entry<T>> | Entry<T>[]) {\n    const tree = new SearchableMap()\n    for (const [key, value] of entries) {\n      tree.set(key, value)\n    }\n    return tree\n  }\n\n  /**\n   * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n   *\n   * @param object  Object of entries for the {@link SearchableMap}\n   * @return A new {@link SearchableMap} with the given entries\n   */\n  static fromObject<T = any> (object: { [key: string]: T }) {\n    return SearchableMap.from<T>(Object.entries(object))\n  }\n}\n\nconst trackDown = <T = any>(tree: RadixTree<T> | undefined, key: string, path: Path<T> = []): [RadixTree<T> | undefined, Path<T>] => {\n  if (key.length === 0 || tree == null) { return [tree, path] }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      path.push([tree, k]) // performance: update in place\n      return trackDown(tree.get(k)!, key.slice(k.length), path)\n    }\n  }\n\n  path.push([tree, key]) // performance: update in place\n  return trackDown(undefined, '', path)\n}\n\nconst lookup = <T = any>(tree: RadixTree<T>, key: string): RadixTree<T> | undefined => {\n  if (key.length === 0 || tree == null) { return tree }\n\n  for (const k of tree.keys()) {\n    if (k !== LEAF && key.startsWith(k)) {\n      return lookup(tree.get(k)!, key.slice(k.length))\n    }\n  }\n}\n\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = <T = any>(node: RadixTree<T>, key: string): RadixTree<T> => {\n  const keyLength = key.length\n\n  outer: for (let pos = 0; node && pos < keyLength;) {\n    for (const k of node.keys()) {\n      // Check whether this key is a candidate: the first characters must match.\n      if (k !== LEAF && key[pos] === k[0]) {\n        const len = Math.min(keyLength - pos, k.length)\n\n        // Advance offset to the point where key and k no longer match.\n        let offset = 1\n        while (offset < len && key[pos + offset] === k[offset]) ++offset\n\n        const child = node.get(k)!\n        if (offset === k.length) {\n          // The existing key is shorter than the key we need to create.\n          node = child\n        } else {\n          // Partial match: we need to insert an intermediate node to contain\n          // both the existing subtree and the new node.\n          const intermediate = new Map()\n          intermediate.set(k.slice(offset), child)\n          node.set(key.slice(pos, pos + offset), intermediate)\n          node.delete(k)\n          node = intermediate\n        }\n\n        pos += offset\n        continue outer\n      }\n    }\n\n    // Create a final child node to contain the final suffix of the key.\n    const child = new Map()\n    node.set(key.slice(pos), child)\n    return child\n  }\n\n  return node\n}\n\nconst remove = <T = any>(tree: RadixTree<T>, key: string): void => {\n  const [node, path] = trackDown(tree, key)\n  if (node === undefined) { return }\n  node.delete(LEAF)\n\n  if (node.size === 0) {\n    cleanup(path)\n  } else if (node.size === 1) {\n    const [key, value] = node.entries().next().value!\n    merge(path, key as string, value as RadixTree<T>)\n  }\n}\n\nconst cleanup = <T = any>(path: Path<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, key] = last(path)\n  node!.delete(key)\n\n  if (node!.size === 0) {\n    cleanup(path.slice(0, -1))\n  } else if (node!.size === 1) {\n    const [key, value] = node!.entries().next().value!\n    if (key !== LEAF) {\n      merge(path.slice(0, -1), key as string, value as RadixTree<T>)\n    }\n  }\n}\n\nconst merge = <T = any>(path: Path<T>, key: string, value: RadixTree<T>): void => {\n  if (path.length === 0) { return }\n\n  const [node, nodeKey] = last(path)\n  node!.set(nodeKey + key, value)\n  node!.delete(nodeKey)\n}\n\nconst last = <T = any>(array: T[]): T => {\n  return array[array.length - 1]\n}\n","import SearchableMap from './SearchableMap/SearchableMap'\n\nexport type LowercaseCombinationOperator = 'or' | 'and' | 'and_not'\nexport type CombinationOperator = LowercaseCombinationOperator | Uppercase<LowercaseCombinationOperator> | Capitalize<LowercaseCombinationOperator>\n\nconst OR: LowercaseCombinationOperator = 'or'\nconst AND: LowercaseCombinationOperator = 'and'\nconst AND_NOT: LowercaseCombinationOperator = 'and_not'\n\n/**\n * Search options to customize the search behavior.\n */\nexport type SearchOptions = {\n  /**\n   * Names of the fields to search in. If omitted, all fields are searched.\n   */\n  fields?: string[],\n\n  /**\n   * Function used to filter search results, for example on the basis of stored\n   * fields. It takes as argument each search result and should return a boolean\n   * to indicate if the result should be kept or not.\n   */\n  filter?: (result: SearchResult) => boolean,\n\n  /**\n   * Key-value object of field names to boosting values. By default, fields are\n   * assigned a boosting factor of 1. If one assigns to a field a boosting value\n   * of 2, a result that matches the query in that field is assigned a score\n   * twice as high as a result matching the query in another field, all else\n   * being equal.\n   */\n  boost?: { [fieldName: string]: number },\n\n  /**\n   * Function to calculate a boost factor for each term.\n   *\n   * This function, if provided, is called for each query term (as split by\n   * `tokenize` and processed by `processTerm`). The arguments passed to the\n   * function are the query term, the positional index of the term in the query,\n   * and the array of all query terms. It is expected to return a numeric boost\n   * factor for the term. A factor lower than 1 reduces the importance of the\n   * term, a factor greater than 1 increases it. A factor of exactly 1 is\n   * neutral, and does not affect the term's importance.\n   */\n  boostTerm?: (term: string, i: number, terms: string[]) => number,\n\n  /**\n   * Relative weights to assign to prefix search results and fuzzy search\n   * results. Exact matches are assigned a weight of 1.\n   */\n  weights?: { fuzzy: number, prefix: number },\n\n  /**\n   * Function to calculate a boost factor for documents. It takes as arguments\n   * the document ID, and a term that matches the search in that document, and\n   * the value of the stored fields for the document (if any).  It should return\n   * a boosting factor: a number higher than 1 increases the computed score, a\n   * number lower than 1 decreases the score, and a falsy value skips the search\n   * result completely.\n   */\n  boostDocument?: (documentId: any, term: string, storedFields?: Record<string, unknown>) => number,\n\n  /**\n   * Controls whether to perform prefix search. It can be a simple boolean, or a\n   * function.\n   *\n   * If a boolean is passed, prefix search is performed if true.\n   *\n   * If a function is passed, it is called upon search with a search term, the\n   * positional index of that search term in the tokenized search query, and the\n   * tokenized search query. The function should return a boolean to indicate\n   * whether to perform prefix search for that search term.\n   */\n  prefix?: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  /**\n   * Controls whether to perform fuzzy search. It can be a simple boolean, or a\n   * number, or a function.\n   *\n   * If a boolean is given, fuzzy search with a default fuzziness parameter is\n   * performed if true.\n   *\n   * If a number higher or equal to 1 is given, fuzzy search is performed, with\n   * a maximum edit distance (Levenshtein) equal to the number.\n   *\n   * If a number between 0 and 1 is given, fuzzy search is performed within a\n   * maximum edit distance corresponding to that fraction of the term length,\n   * approximated to the nearest integer. For example, 0.2 would mean an edit\n   * distance of 20% of the term length, so 1 character in a 5-characters term.\n   * The calculated fuzziness value is limited by the `maxFuzzy` option, to\n   * prevent slowdown for very long queries.\n   *\n   * If a function is passed, the function is called upon search with a search\n   * term, a positional index of that term in the tokenized search query, and\n   * the tokenized search query. It should return a boolean or a number, with\n   * the meaning documented above.\n   */\n  fuzzy?: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  /**\n   * Controls the maximum fuzziness when using a fractional fuzzy value. This is\n   * set to 6 by default. Very high edit distances usually don't produce\n   * meaningful results, but can excessively impact search performance.\n   */\n  maxFuzzy?: number,\n\n  /**\n   * The operand to combine partial results for each term. By default it is\n   * \"OR\", so results matching _any_ of the search terms are returned by a\n   * search. If \"AND\" is given, only results matching _all_ the search terms are\n   * returned by a search.\n   */\n  combineWith?: CombinationOperator,\n\n  /**\n   * Function to tokenize the search query. By default, the same tokenizer used\n   * for indexing is used also for search.\n   *\n   * @remarks This function is called after `extractField` extracts a truthy\n   * value from a field. This function is then expected to split the extracted\n   * `text` document into tokens (more commonly referred to as \"terms\" in this\n   * context). The resulting split might be simple, like for example on word\n   * boundaries, or it might be more complex, taking into account certain\n   * encoding, or parsing needs, or even just special cases. Think about how one\n   * might need to go about indexing the term \"short-term\". You would likely\n   * want to treat this case specially, and return two terms instead, `[\n   * \"short\", \"term\" ]`.\n   *\n   * Or, you could let such a case be handled by the `processTerm` function,\n   * which is designed to turn each token/term into whole terms or sub-terms. In\n   * any case, the purpose of this function is to split apart the provided\n   * `text` document into parts that can be processed by the `processTerm`\n   * function.\n   */\n  tokenize?: (text: string) => string[],\n\n  /**\n   * Function to process or normalize terms in the search query. By default, the\n   * same term processor used for indexing is used also for search.\n   *\n   * @remarks\n   * During the document indexing phase, the first step is to call the\n   * `extractField` function to fetch the requested value/field from the\n   * document. This is then passed off to the `tokenize` function, which will\n   * break apart each value into \"terms\". These terms are then individually\n   * passed through this function to compute each term individually. A term\n   * might for example be something like \"lbs\", in which case one would likely\n   * want to return `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return\n   * just a single string, or a falsy value if you would like to skip indexing\n   * entirely for a specific term.\n   *\n   * Truthy return value(s) are then fed to the indexer as positive matches for\n   * this document. In our example above, all four of the `[ \"lbs\", \"lb\",\n   * \"pound\", \"pounds\" ]` terms would be added to the indexing engine, matching\n   * against the current document being computed.\n   *\n   * *Note: Whatever values are returned from this function will receive no\n   * further processing before being indexed. This means for example, if you\n   * include whitespace at the beginning or end of a word, it will also be\n   * indexed that way, with the included whitespace.*\n   */\n  processTerm?: (term: string) => string | string[] | null | undefined | false\n\n  /**\n   * BM25+ algorithm parameters. Customizing these is almost never necessary,\n   * and finetuning them requires an understanding of the BM25 scoring model. In\n   * most cases, it is best to omit this option to use defaults, and instead use\n   * boosting to tweak scoring for specific use cases.\n   */\n  bm25?: BM25Params\n}\n\ntype SearchOptionsWithDefaults = SearchOptions & {\n  boost: { [fieldName: string]: number },\n\n  weights: { fuzzy: number, prefix: number },\n\n  prefix: boolean | ((term: string, index: number, terms: string[]) => boolean),\n\n  fuzzy: boolean | number | ((term: string, index: number, terms: string[]) => boolean | number),\n\n  maxFuzzy: number,\n\n  combineWith: CombinationOperator\n\n  bm25: BM25Params\n}\n\n/**\n * Configuration options passed to the {@link MiniSearch} constructor\n *\n * @typeParam T  The type of documents being indexed.\n */\nexport type Options<T = any> = {\n   /**\n    * Names of the document fields to be indexed.\n    */\n  fields: string[],\n\n   /**\n    * Name of the ID field, uniquely identifying a document.\n    */\n  idField?: string,\n\n   /**\n    * Names of fields to store, so that search results would include them. By\n    * default none, so results would only contain the id field.\n    */\n  storeFields?: string[],\n\n   /**\n    * Function used to extract the value of each field in documents. By default,\n    * the documents are assumed to be plain objects with field names as keys,\n    * but by specifying a custom `extractField` function one can completely\n    * customize how the fields are extracted.\n    *\n    * The function takes as arguments the document, and the name of the field to\n    * extract from it. It should return the field value as a string.\n    *\n    * @remarks\n    * The returned string is fed into the `tokenize` function to split it up\n    * into tokens.\n    */\n  extractField?: (document: T, fieldName: string) => any,\n\n  /**\n   * Function used to turn field values into strings for indexing\n   *\n   * The function takes as arguments the field value, and the name of the field\n   * to stringify, so that its logic can be customized on specific fields. By\n   * default, it simply calls `toString()` on the field value (which in many\n   * cases is already a string).\n   *\n   * ### Example:\n   *\n   * ```javascript\n   * // Custom stringifier that formats dates as \"Tuesday, September 16, 2025\"\n   * const miniSearch = new MiniSearch({\n   *   fields: ['title', 'date'],\n   *   stringifyField: ((fieldValue, _fieldName) => {\n   *     if (fieldValue instanceof Date) {\n   *       return fieldValue.toLocaleDateString('en-US', {\n   *         weekday: 'long',\n   *         year: 'numeric',\n   *         month: 'long',\n   *         day: 'numeric'\n   *       })\n   *     } else {\n   *      return fieldValue.toString()\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  stringifyField?: (fieldValue: any, fieldName: string) => string,\n\n   /**\n    * Function used to split a field value into individual terms to be indexed.\n    * The default tokenizer separates terms by space or punctuation, but a\n    * custom tokenizer can be provided for custom logic.\n    *\n    * The function takes as arguments string to tokenize, and the name of the\n    * field it comes from. It should return the terms as an array of strings.\n    * When used for tokenizing a search query instead of a document field, the\n    * `fieldName` is undefined.\n    *\n    * @remarks\n    * This function is called after `extractField` extracts a truthy value from a\n    * field. This function is then expected to split the extracted `text` document\n    * into tokens (more commonly referred to as \"terms\" in this context). The resulting\n    * split might be simple, like for example on word boundaries, or it might be more\n    * complex, taking into account certain encoding, or parsing needs, or even just\n    * special cases. Think about how one might need to go about indexing the term\n    * \"short-term\". You would likely want to treat this case specially, and return two\n    * terms instead, `[ \"short\", \"term\" ]`.\n    *\n    * Or, you could let such a case be handled by the `processTerm` function,\n    * which is designed to turn each token/term into whole terms or sub-terms. In any\n    * case, the purpose of this function is to split apart the provided `text` document\n    * into parts that can be processed by the `processTerm` function.\n    */\n  tokenize?: (text: string, fieldName?: string) => string[],\n\n   /**\n    * Function used to process a term before indexing or search. This can be\n    * used for normalization (such as stemming). By default, terms are\n    * downcased, and otherwise no other normalization is performed.\n    *\n    * The function takes as arguments a term to process, and the name of the\n    * field it comes from. It should return the processed term as a string, or a\n    * falsy value to reject the term entirely.\n    *\n    * It can also return an array of strings, in which case each string in the\n    * returned array is indexed as a separate term.\n    *\n    * @remarks\n    * During the document indexing phase, the first step is to call the `extractField`\n    * function to fetch the requested value/field from the document. This is then\n    * passed off to the `tokenizer`, which will break apart each value into \"terms\".\n    * These terms are then individually passed through the `processTerm` function\n    * to compute each term individually. A term might for example be something\n    * like \"lbs\", in which case one would likely want to return\n    * `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`. You may also return a single string value,\n    * or a falsy value if you would like to skip indexing entirely for a specific term.\n    *\n    * Truthy return value(s) are then fed to the indexer as positive matches for this\n    * document. In our example above, all four of the `[ \"lbs\", \"lb\", \"pound\", \"pounds\" ]`\n    * terms would be added to the indexing engine, matching against the current document\n    * being computed.\n    *\n    * *Note: Whatever values are returned from this function will receive no further\n    * processing before being indexed. This means for example, if you include whitespace\n    * at the beginning or end of a word, it will also be indexed that way, with the\n    * included whitespace.*\n    */\n  processTerm?: (term: string, fieldName?: string) => string | string[] | null | undefined | false,\n\n  /**\n   * Function called to log messages. Arguments are a log level ('debug',\n   * 'info', 'warn', or 'error'), a log message, and an optional string code\n   * that identifies the reason for the log.\n   *\n   * The default implementation uses `console`, if defined.\n   */\n  logger?: (level: LogLevel, message: string, code?: string) => void\n\n  /**\n   * If `true` (the default), vacuuming is performed automatically as soon as\n   * {@link MiniSearch#discard} is called a certain number of times, cleaning up\n   * obsolete references from the index. If `false`, no automatic vacuuming is\n   * performed. Custom settings controlling auto vacuuming thresholds, as well\n   * as batching behavior, can be passed as an object (see the {@link\n   * AutoVacuumOptions} type).\n   */\n  autoVacuum?: boolean | AutoVacuumOptions\n\n   /**\n    * Default search options (see the {@link SearchOptions} type and the {@link\n    * MiniSearch#search} method for details)\n    */\n  searchOptions?: SearchOptions,\n\n   /**\n    * Default auto suggest options (see the {@link SearchOptions} type and the\n    * {@link MiniSearch#autoSuggest} method for details)\n    */\n  autoSuggestOptions?: SearchOptions\n}\n\ntype OptionsWithDefaults<T = any> = Options<T> & {\n  storeFields: string[]\n\n  idField: string\n\n  extractField: (document: T, fieldName: string) => any\n\n  stringifyField: (fieldValue: any, fieldName: string) => string\n\n  tokenize: (text: string, fieldName: string) => string[]\n\n  processTerm: (term: string, fieldName: string) => string | string[] | null | undefined | false\n\n  logger: (level: LogLevel, message: string, code?: string) => void\n\n  autoVacuum: false | AutoVacuumOptions\n\n  searchOptions: SearchOptionsWithDefaults\n\n  autoSuggestOptions: SearchOptions\n}\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/**\n * The type of auto-suggestions\n */\nexport type Suggestion = {\n  /**\n   * The suggestion\n   */\n  suggestion: string,\n\n  /**\n   * Suggestion as an array of terms\n   */\n  terms: string[],\n\n  /**\n   * Score for the suggestion\n   */\n  score: number\n}\n\n/**\n * Match information for a search result. It is a key-value object where keys\n * are terms that matched, and values are the list of fields that the term was\n * found in.\n */\nexport type MatchInfo = {\n  [term: string]: string[]\n}\n\n/**\n * Type of the search results. Each search result indicates the document ID, the\n * terms that matched, the match information, the score, and all the stored\n * fields.\n */\nexport type SearchResult = {\n  /**\n   * The document ID\n   */\n  id: any,\n\n  /**\n   * List of document terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `terms` will contain `\"motorcycle\"`.\n   */\n  terms: string[],\n\n  /**\n   * List of query terms that matched. For example, if a prefix search for\n   * `\"moto\"` matches `\"motorcycle\"`, `queryTerms` will contain `\"moto\"`.\n   */\n  queryTerms: string[],\n\n  /**\n   * Score of the search results\n   */\n  score: number,\n\n  /**\n   * Match information, see {@link MatchInfo}\n   */\n  match: MatchInfo,\n\n  /**\n   * Stored fields\n   */\n  [key: string]: any\n}\n\n/**\n * @ignore\n */\nexport type AsPlainObject = {\n  documentCount: number,\n  nextId: number,\n  documentIds: { [shortId: string]: any }\n  fieldIds: { [fieldName: string]: number }\n  fieldLength: { [shortId: string]: number[] }\n  averageFieldLength: number[],\n  storedFields: { [shortId: string]: any }\n  dirtCount?: number,\n  index: [string, { [fieldId: string]: SerializedIndexEntry }][]\n  serializationVersion: number\n}\n\nexport type QueryCombination = SearchOptions & { queries: Query[] }\n\n/**\n * Wildcard query, used to match all terms\n */\nexport type Wildcard = typeof MiniSearch.wildcard\n\n/**\n * Search query expression, either a query string or an expression tree\n * combining several queries with a combination of AND or OR.\n */\nexport type Query = QueryCombination | string | Wildcard\n\n/**\n * Options to control vacuuming behavior.\n *\n * Vacuuming cleans up document references made obsolete by {@link\n * MiniSearch.discard} from the index. On large indexes, vacuuming is\n * potentially costly, because it has to traverse the whole inverted index.\n * Therefore, in order to dilute this cost so it does not negatively affects the\n * application, vacuuming is performed in batches, with a delay between each\n * batch. These options are used to configure the batch size and the delay\n * between batches.\n */\nexport type VacuumOptions = {\n  /**\n   * Size of each vacuuming batch (the number of terms in the index that will be\n   * traversed in each batch). Defaults to 1000.\n   */\n  batchSize?: number,\n\n  /**\n   * Wait time between each vacuuming batch in milliseconds. Defaults to 10.\n   */\n  batchWait?: number\n}\n\n/**\n * Sets minimum thresholds for `dirtCount` and `dirtFactor` that trigger an\n * automatic vacuuming.\n */\nexport type VacuumConditions = {\n  /**\n   * Minimum `dirtCount` (number of discarded documents since the last vacuuming)\n   * under which auto vacuum is not triggered. It defaults to 20.\n   */\n  minDirtCount?: number\n\n  /**\n   * Minimum `dirtFactor` (proportion of discarded documents over the total)\n   * under which auto vacuum is not triggered. It defaults to 0.1.\n   */\n  minDirtFactor?: number,\n}\n\n/**\n * Options to control auto vacuum behavior. When discarding a document with\n * {@link MiniSearch#discard}, a vacuuming operation is automatically started if\n * the `dirtCount` and `dirtFactor` are above the `minDirtCount` and\n * `minDirtFactor` thresholds defined by this configuration. See {@link\n * VacuumConditions} for details on these.\n *\n * Also, `batchSize` and `batchWait` can be specified, controlling batching\n * behavior (see {@link VacuumOptions}).\n */\nexport type AutoVacuumOptions = VacuumOptions & VacuumConditions\n\ntype QuerySpec = {\n  prefix: boolean,\n  fuzzy: number | boolean,\n  term: string,\n  termBoost: number\n}\n\ntype DocumentTermFreqs = Map<number, number>\ntype FieldTermData = Map<number, DocumentTermFreqs>\n\ninterface RawResultValue {\n  // Intermediate score, before applying the final score based on number of\n  // matched terms.\n  score: number,\n\n  // Set of all query terms that were matched. They may not be present in the\n  // text exactly in the case of prefix/fuzzy matches. We must check for\n  // uniqueness before adding a new term. This is much faster than using a set,\n  // because the number of elements is relatively small.\n  terms: string[],\n\n  // All terms that were found in the content, including the fields in which\n  // they were present. This object will be provided as part of the final search\n  // results.\n  match: MatchInfo,\n}\n\ntype RawResult = Map<number, RawResultValue>\n\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nexport default class MiniSearch<T = any> {\n  protected _options: OptionsWithDefaults<T>\n  protected _index: SearchableMap<FieldTermData>\n  protected _documentCount: number\n  protected _documentIds: Map<number, any>\n  protected _idToShortId: Map<any, number>\n  protected _fieldIds: { [key: string]: number }\n  protected _fieldLength: Map<number, number[]>\n  protected _avgFieldLength: number[]\n  protected _nextId: number\n  protected _storedFields: Map<number, Record<string, unknown>>\n  protected _dirtCount: number\n  private _currentVacuum: Promise<void> | null\n  private _enqueuedVacuum: Promise<void> | null\n  private _enqueuedVacuumConditions: VacuumConditions | undefined\n\n  /**\n   * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n   * to match all documents\n   */\n  static readonly wildcard: unique symbol = Symbol('*')\n\n  /**\n   * @param options  Configuration options\n   *\n   * ### Examples:\n   *\n   * ```javascript\n   * // Create a search engine that indexes the 'title' and 'text' fields of your\n   * // documents:\n   * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * ```\n   *\n   * ### ID Field:\n   *\n   * ```javascript\n   * // Your documents are assumed to include a unique 'id' field, but if you want\n   * // to use a different field for document identification, you can set the\n   * // 'idField' option:\n   * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n   * ```\n   *\n   * ### Options and defaults:\n   *\n   * ```javascript\n   * // The full set of options (here with their default value) is:\n   * const miniSearch = new MiniSearch({\n   *   // idField: field that uniquely identifies a document\n   *   idField: 'id',\n   *\n   *   // extractField: function used to get the value of a field in a document.\n   *   // By default, it assumes the document is a flat object with field names as\n   *   // property keys and field values as string property values, but custom logic\n   *   // can be implemented by setting this option to a custom extractor function.\n   *   extractField: (document, fieldName) => document[fieldName],\n   *\n   *   // tokenize: function used to split fields into individual terms. By\n   *   // default, it is also used to tokenize search queries, unless a specific\n   *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n   *   // the field name is passed as the second argument.\n   *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n   *\n   *   // processTerm: function used to process each tokenized term before\n   *   // indexing. It can be used for stemming and normalization. Return a falsy\n   *   // value in order to discard a term. By default, it is also used to process\n   *   // search queries, unless a specific `processTerm` option is supplied as a\n   *   // search option. When processing a term from a indexed field, the field\n   *   // name is passed as the second argument.\n   *   processTerm: (term, _fieldName) => term.toLowerCase(),\n   *\n   *   // searchOptions: default search options, see the `search` method for\n   *   // details\n   *   searchOptions: undefined,\n   *\n   *   // fields: document fields to be indexed. Mandatory, but not set by default\n   *   fields: undefined\n   *\n   *   // storeFields: document fields to be stored and returned as part of the\n   *   // search results.\n   *   storeFields: []\n   * })\n   * ```\n   */\n  constructor (options: Options<T>) {\n    if (options?.fields == null) {\n      throw new Error('MiniSearch: option \"fields\" must be provided')\n    }\n\n    const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum\n\n    this._options = {\n      ...defaultOptions,\n      ...options,\n      autoVacuum,\n      searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n      autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n    }\n\n    this._index = new SearchableMap()\n\n    this._documentCount = 0\n\n    this._documentIds = new Map()\n\n    this._idToShortId = new Map()\n\n    // Fields are defined during initialization, don't change, are few in\n    // number, rarely need iterating over, and have string keys. Therefore in\n    // this case an object is a better candidate than a Map to store the mapping\n    // from field key to ID.\n    this._fieldIds = {}\n\n    this._fieldLength = new Map()\n\n    this._avgFieldLength = []\n\n    this._nextId = 0\n\n    this._storedFields = new Map()\n\n    this._dirtCount = 0\n\n    this._currentVacuum = null\n\n    this._enqueuedVacuum = null\n    this._enqueuedVacuumConditions = defaultVacuumConditions\n\n    this.addFields(this._options.fields)\n  }\n\n  /**\n   * Adds a document to the index\n   *\n   * @param document  The document to be indexed\n   */\n  add (document: T): void {\n    const { extractField, stringifyField, tokenize, processTerm, fields, idField } = this._options\n    const id = extractField(document, idField)\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    if (this._idToShortId.has(id)) {\n      throw new Error(`MiniSearch: duplicate ID ${id}`)\n    }\n\n    const shortDocumentId = this.addDocumentId(id)\n    this.saveStoredFields(shortDocumentId, document)\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.addTerm(fieldId, shortDocumentId, t)\n          }\n        } else if (processedTerm) {\n          this.addTerm(fieldId, shortDocumentId, processedTerm)\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds all the given documents to the index\n   *\n   * @param documents  An array of documents to be indexed\n   */\n  addAll (documents: readonly T[]): void {\n    for (const document of documents) this.add(document)\n  }\n\n  /**\n   * Adds all the given documents to the index asynchronously.\n   *\n   * Returns a promise that resolves (to `undefined`) when the indexing is done.\n   * This method is useful when index many documents, to avoid blocking the main\n   * thread. The indexing is performed asynchronously and in chunks.\n   *\n   * @param documents  An array of documents to be indexed\n   * @param options  Configuration options\n   * @return A promise resolving to `undefined` when the indexing is done\n   */\n  addAllAsync (documents: readonly T[], options: { chunkSize?: number } = {}): Promise<void> {\n    const { chunkSize = 10 } = options\n    const acc: { chunk: T[], promise: Promise<void> } = { chunk: [], promise: Promise.resolve() }\n\n    const { chunk, promise } = documents.reduce(({ chunk, promise }, document: T, i: number) => {\n      chunk.push(document)\n      if ((i + 1) % chunkSize === 0) {\n        return {\n          chunk: [],\n          promise: promise\n            .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n            .then(() => this.addAll(chunk))\n        }\n      } else {\n        return { chunk, promise }\n      }\n    }, acc)\n\n    return promise.then(() => this.addAll(chunk))\n  }\n\n  /**\n   * Removes the given document from the index.\n   *\n   * The document to remove must NOT have changed between indexing and removal,\n   * otherwise the index will be corrupted.\n   *\n   * This method requires passing the full document to be removed (not just the\n   * ID), and immediately removes the document from the inverted index, allowing\n   * memory to be released. A convenient alternative is {@link\n   * MiniSearch#discard}, which needs only the document ID, and has the same\n   * visible effect, but delays cleaning up the index until the next vacuuming.\n   *\n   * @param document  The document to be removed\n   */\n  remove (document: T): void {\n    const { tokenize, processTerm, extractField, stringifyField, fields, idField } = this._options\n    const id = extractField(document, idField)\n\n    if (id == null) {\n      throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`)\n    }\n\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`)\n    }\n\n    for (const field of fields) {\n      const fieldValue = extractField(document, field)\n      if (fieldValue == null) continue\n\n      const tokens = tokenize(stringifyField(fieldValue, field), field)\n      const fieldId = this._fieldIds[field]\n\n      const uniqueTerms = new Set(tokens).size\n      this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms)\n\n      for (const term of tokens) {\n        const processedTerm = processTerm(term, field)\n        if (Array.isArray(processedTerm)) {\n          for (const t of processedTerm) {\n            this.removeTerm(fieldId, shortId, t)\n          }\n        } else if (processedTerm) {\n          this.removeTerm(fieldId, shortId, processedTerm)\n        }\n      }\n    }\n\n    this._storedFields.delete(shortId)\n    this._documentIds.delete(shortId)\n    this._idToShortId.delete(id)\n    this._fieldLength.delete(shortId)\n    this._documentCount -= 1\n  }\n\n  /**\n   * Removes all the given documents from the index. If called with no arguments,\n   * it removes _all_ documents from the index.\n   *\n   * @param documents  The documents to be removed. If this argument is omitted,\n   * all documents are removed. Note that, for removing all documents, it is\n   * more efficient to call this method with no arguments than to pass all\n   * documents.\n   */\n  removeAll (documents?: readonly T[]): void {\n    if (documents) {\n      for (const document of documents) this.remove(document)\n    } else if (arguments.length > 0) {\n      throw new Error('Expected documents to be present. Omit the argument to remove all documents.')\n    } else {\n      this._index = new SearchableMap()\n      this._documentCount = 0\n      this._documentIds = new Map()\n      this._idToShortId = new Map()\n      this._fieldLength = new Map()\n      this._avgFieldLength = []\n      this._storedFields = new Map()\n      this._nextId = 0\n    }\n  }\n\n  /**\n   * Discards the document with the given ID, so it won't appear in search results\n   *\n   * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n   * document to stop appearing in searches), but a different effect on the\n   * internal data structures:\n   *\n   *   - {@link MiniSearch#remove} requires passing the full document to be\n   *   removed as argument, and removes it from the inverted index immediately.\n   *\n   *   - {@link MiniSearch#discard} instead only needs the document ID, and\n   *   works by marking the current version of the document as discarded, so it\n   *   is immediately ignored by searches. This is faster and more convenient\n   *   than {@link MiniSearch#remove}, but the index is not immediately\n   *   modified. To take care of that, vacuuming is performed after a certain\n   *   number of documents are discarded, cleaning up the index and allowing\n   *   memory to be released.\n   *\n   * After discarding a document, it is possible to re-add a new version, and\n   * only the new version will appear in searches. In other words, discarding\n   * and re-adding a document works exactly like removing and re-adding it. The\n   * {@link MiniSearch.replace} method can also be used to replace a document\n   * with a new version.\n   *\n   * #### Details about vacuuming\n   *\n   * Repetite calls to this method would leave obsolete document references in\n   * the index, invisible to searches. Two mechanisms take care of cleaning up:\n   * clean up during search, and vacuuming.\n   *\n   *   - Upon search, whenever a discarded ID is found (and ignored for the\n   *   results), references to the discarded document are removed from the\n   *   inverted index entries for the search terms. This ensures that subsequent\n   *   searches for the same terms do not need to skip these obsolete references\n   *   again.\n   *\n   *   - In addition, vacuuming is performed automatically by default (see the\n   *   `autoVacuum` field in {@link Options}) after a certain number of\n   *   documents are discarded. Vacuuming traverses all terms in the index,\n   *   cleaning up all references to discarded documents. Vacuuming can also be\n   *   triggered manually by calling {@link MiniSearch#vacuum}.\n   *\n   * @param id  The ID of the document to be discarded\n   */\n  discard (id: any): void {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) {\n      throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`)\n    }\n\n    this._idToShortId.delete(id)\n    this._documentIds.delete(shortId)\n    this._storedFields.delete(shortId)\n\n    ;(this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n      this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength)\n    })\n\n    this._fieldLength.delete(shortId)\n\n    this._documentCount -= 1\n    this._dirtCount += 1\n\n    this.maybeAutoVacuum()\n  }\n\n  private maybeAutoVacuum (): void {\n    if (this._options.autoVacuum === false) { return }\n\n    const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum\n    this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor })\n  }\n\n  /**\n   * Discards the documents with the given IDs, so they won't appear in search\n   * results\n   *\n   * It is equivalent to calling {@link MiniSearch#discard} for all the given\n   * IDs, but with the optimization of triggering at most one automatic\n   * vacuuming at the end.\n   *\n   * Note: to remove all documents from the index, it is faster and more\n   * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n   * of passing all IDs to this method.\n   */\n  discardAll (ids: readonly any[]): void {\n    const autoVacuum = this._options.autoVacuum\n\n    try {\n      this._options.autoVacuum = false\n\n      for (const id of ids) {\n        this.discard(id)\n      }\n    } finally {\n      this._options.autoVacuum = autoVacuum\n    }\n\n    this.maybeAutoVacuum()\n  }\n\n  /**\n   * It replaces an existing document with the given updated version\n   *\n   * It works by discarding the current version and adding the updated one, so\n   * it is functionally equivalent to calling {@link MiniSearch#discard}\n   * followed by {@link MiniSearch#add}. The ID of the updated document should\n   * be the same as the original one.\n   *\n   * Since it uses {@link MiniSearch#discard} internally, this method relies on\n   * vacuuming to clean up obsolete document references from the index, allowing\n   * memory to be released (see {@link MiniSearch#discard}).\n   *\n   * @param updatedDocument  The updated document to replace the old version\n   * with\n   */\n  replace (updatedDocument: T): void {\n    const { idField, extractField } = this._options\n    const id = extractField(updatedDocument, idField)\n\n    this.discard(id)\n    this.add(updatedDocument)\n  }\n\n  /**\n   * Triggers a manual vacuuming, cleaning up references to discarded documents\n   * from the inverted index\n   *\n   * Vacuuming is only useful for applications that use the {@link\n   * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n   *\n   * By default, vacuuming is performed automatically when needed (controlled by\n   * the `autoVacuum` field in {@link Options}), so there is usually no need to\n   * call this method, unless one wants to make sure to perform vacuuming at a\n   * specific moment.\n   *\n   * Vacuuming traverses all terms in the inverted index in batches, and cleans\n   * up references to discarded documents from the posting list, allowing memory\n   * to be released.\n   *\n   * The method takes an optional object as argument with the following keys:\n   *\n   *   - `batchSize`: the size of each batch (1000 by default)\n   *\n   *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n   *   default)\n   *\n   * On large indexes, vacuuming could have a non-negligible cost: batching\n   * avoids blocking the thread for long, diluting this cost so that it is not\n   * negatively affecting the application. Nonetheless, this method should only\n   * be called when necessary, and relying on automatic vacuuming is usually\n   * better.\n   *\n   * It returns a promise that resolves (to undefined) when the clean up is\n   * completed. If vacuuming is already ongoing at the time this method is\n   * called, a new one is enqueued immediately after the ongoing one, and a\n   * corresponding promise is returned. However, no more than one vacuuming is\n   * enqueued on top of the ongoing one, even if this method is called more\n   * times (enqueuing multiple ones would be useless).\n   *\n   * @param options  Configuration options for the batch size and delay. See\n   * {@link VacuumOptions}.\n   */\n  vacuum (options: VacuumOptions = {}): Promise<void> {\n    return this.conditionalVacuum(options)\n  }\n\n  private conditionalVacuum (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    // If a vacuum is already ongoing, schedule another as soon as it finishes,\n    // unless there's already one enqueued. If one was already enqueued, do not\n    // enqueue another on top, but make sure that the conditions are the\n    // broadest.\n    if (this._currentVacuum) {\n      this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions\n      if (this._enqueuedVacuum != null) { return this._enqueuedVacuum }\n\n      this._enqueuedVacuum = this._currentVacuum.then(() => {\n        const conditions = this._enqueuedVacuumConditions\n        this._enqueuedVacuumConditions = defaultVacuumConditions\n        return this.performVacuuming(options, conditions)\n      })\n      return this._enqueuedVacuum\n    }\n\n    if (this.vacuumConditionsMet(conditions) === false) { return Promise.resolve() }\n\n    this._currentVacuum = this.performVacuuming(options)\n    return this._currentVacuum\n  }\n\n  private async performVacuuming (options: VacuumOptions, conditions?: VacuumConditions): Promise<void> {\n    const initialDirtCount = this._dirtCount\n\n    if (this.vacuumConditionsMet(conditions)) {\n      const batchSize = options.batchSize || defaultVacuumOptions.batchSize\n      const batchWait = options.batchWait || defaultVacuumOptions.batchWait\n      let i = 1\n\n      for (const [term, fieldsData] of this._index) {\n        for (const [fieldId, fieldIndex] of fieldsData) {\n          for (const [shortId] of fieldIndex) {\n            if (this._documentIds.has(shortId)) { continue }\n\n            if (fieldIndex.size <= 1) {\n              fieldsData.delete(fieldId)\n            } else {\n              fieldIndex.delete(shortId)\n            }\n          }\n        }\n\n        if (this._index.get(term)!.size === 0) {\n          this._index.delete(term)\n        }\n\n        if (i % batchSize === 0) {\n          await new Promise((resolve) => setTimeout(resolve, batchWait))\n        }\n\n        i += 1\n      }\n\n      this._dirtCount -= initialDirtCount\n    }\n\n    // Make the next lines always async, so they execute after this function returns\n    await null\n\n    this._currentVacuum = this._enqueuedVacuum\n    this._enqueuedVacuum = null\n  }\n\n  private vacuumConditionsMet (conditions?: VacuumConditions) {\n    if (conditions == null) { return true }\n\n    let { minDirtCount, minDirtFactor } = conditions\n    minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount\n    minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor\n\n    return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor\n  }\n\n  /**\n   * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n   */\n  get isVacuuming (): boolean {\n    return this._currentVacuum != null\n  }\n\n  /**\n   * The number of documents discarded since the most recent vacuuming\n   */\n  get dirtCount (): number {\n    return this._dirtCount\n  }\n\n  /**\n   * A number between 0 and 1 giving an indication about the proportion of\n   * documents that are discarded, and can therefore be cleaned up by vacuuming.\n   * A value close to 0 means that the index is relatively clean, while a higher\n   * value means that the index is relatively dirty, and vacuuming could release\n   * memory.\n   */\n  get dirtFactor (): number {\n    return this._dirtCount / (1 + this._documentCount + this._dirtCount)\n  }\n\n  /**\n   * Returns `true` if a document with the given ID is present in the index and\n   * available for search, `false` otherwise\n   *\n   * @param id  The document ID\n   */\n  has (id: any): boolean {\n    return this._idToShortId.has(id)\n  }\n\n  /**\n   * Returns the stored fields (as configured in the `storeFields` constructor\n   * option) for the given document ID. Returns `undefined` if the document is\n   * not present in the index.\n   *\n   * @param id  The document ID\n   */\n  getStoredFields (id: any): Record<string, unknown> | undefined {\n    const shortId = this._idToShortId.get(id)\n\n    if (shortId == null) { return undefined }\n\n    return this._storedFields.get(shortId)\n  }\n\n  /**\n   * Search for documents matching the given search query.\n   *\n   * The result is a list of scored document IDs matching the query, sorted by\n   * descending score, and each including data about which terms were matched and\n   * in which fields.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Search for \"zen art motorcycle\" with default options: terms have to match\n   * // exactly, and individual terms are joined with OR\n   * miniSearch.search('zen art motorcycle')\n   * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n   * ```\n   *\n   * ### Restrict search to specific fields:\n   *\n   * ```javascript\n   * // Search only in the 'title' field\n   * miniSearch.search('zen', { fields: ['title'] })\n   * ```\n   *\n   * ### Field boosting:\n   *\n   * ```javascript\n   * // Boost a field\n   * miniSearch.search('zen', { boost: { title: 2 } })\n   * ```\n   *\n   * ### Prefix search:\n   *\n   * ```javascript\n   * // Search for \"moto\" with prefix search (it will match documents\n   * // containing terms that start with \"moto\" or \"neuro\")\n   * miniSearch.search('moto neuro', { prefix: true })\n   * ```\n   *\n   * ### Fuzzy search:\n   *\n   * ```javascript\n   * // Search for \"ismael\" with fuzzy search (it will match documents containing\n   * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n   * // (rounded to nearest integer)\n   * miniSearch.search('ismael', { fuzzy: 0.2 })\n   * ```\n   *\n   * ### Combining strategies:\n   *\n   * ```javascript\n   * // Mix of exact match, prefix search, and fuzzy search\n   * miniSearch.search('ismael mob', {\n   *  prefix: true,\n   *  fuzzy: 0.2\n   * })\n   * ```\n   *\n   * ### Advanced prefix and fuzzy search:\n   *\n   * ```javascript\n   * // Perform fuzzy and prefix search depending on the search term. Here\n   * // performing prefix and fuzzy search only on terms longer than 3 characters\n   * miniSearch.search('ismael mob', {\n   *  prefix: term => term.length > 3\n   *  fuzzy: term => term.length > 3 ? 0.2 : null\n   * })\n   * ```\n   *\n   * ### Combine with AND:\n   *\n   * ```javascript\n   * // Combine search terms with AND (to match only documents that contain both\n   * // \"motorcycle\" and \"art\")\n   * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n   * ```\n   *\n   * ### Combine with AND_NOT:\n   *\n   * There is also an AND_NOT combinator, that finds documents that match the\n   * first term, but do not match any of the other terms. This combinator is\n   * rarely useful with simple queries, and is meant to be used with advanced\n   * query combinations (see later for more details).\n   *\n   * ### Filtering results:\n   *\n   * ```javascript\n   * // Filter only results in the 'fiction' category (assuming that 'category'\n   * // is a stored field)\n   * miniSearch.search('motorcycle art', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Wildcard query\n   *\n   * Searching for an empty string (assuming the default tokenizer) returns no\n   * results. Sometimes though, one needs to match all documents, like in a\n   * \"wildcard\" search. This is possible by passing the special value\n   * {@link MiniSearch.wildcard} as the query:\n   *\n   * ```javascript\n   * // Return search results for all documents\n   * miniSearch.search(MiniSearch.wildcard)\n   * ```\n   *\n   * Note that search options such as `filter` and `boostDocument` are still\n   * applied, influencing which results are returned, and their order:\n   *\n   * ```javascript\n   * // Return search results for all documents in the 'fiction' category\n   * miniSearch.search(MiniSearch.wildcard, {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * ```\n   *\n   * ### Advanced combination of queries:\n   *\n   * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n   * and even with different search options, by passing a query expression\n   * tree object as the first argument, instead of a string.\n   *\n   * ```javascript\n   * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n   * miniSearch.search({\n   *   combineWith: 'AND',\n   *   queries: [\n   *     'zen',\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['motorcycle', 'archery']\n   *     }\n   *   ]\n   * })\n   *\n   * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n   * // not \"tree\"\n   * miniSearch.search({\n   *   combineWith: 'AND_NOT',\n   *   queries: [\n   *     {\n   *       combineWith: 'OR',\n   *       queries: ['apple', 'pear']\n   *     },\n   *     'juice',\n   *     'tree'\n   *   ]\n   * })\n   * ```\n   *\n   * Each node in the expression tree can be either a string, or an object that\n   * supports all {@link SearchOptions} fields, plus a `queries` array field for\n   * subqueries.\n   *\n   * Note that, while this can become complicated to do by hand for complex or\n   * deeply nested queries, it provides a formalized expression tree API for\n   * external libraries that implement a parser for custom query languages.\n   *\n   * @param query  Search query\n   * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n   */\n  search (query: Query, searchOptions: SearchOptions = {}): SearchResult[] {\n    const { searchOptions: globalSearchOptions } = this._options\n    const searchOptionsWithDefaults: SearchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions }\n\n    const rawResults = this.executeQuery(query, searchOptions)\n    const results = []\n\n    for (const [docId, { score, terms, match }] of rawResults) {\n      // terms are the matched query terms, which will be returned to the user\n      // as queryTerms. The quality is calculated based on them, as opposed to\n      // the matched terms in the document (which can be different due to\n      // prefix and fuzzy match)\n      const quality = terms.length || 1\n\n      const result = {\n        id: this._documentIds.get(docId),\n        score: score * quality,\n        terms: Object.keys(match),\n        queryTerms: terms,\n        match\n      }\n\n      Object.assign(result, this._storedFields.get(docId))\n      if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n        results.push(result)\n      }\n    }\n\n    // If it's a wildcard query, and no document boost is applied, skip sorting\n    // the results, as all results have the same score of 1\n    if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n      return results\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Provide suggestions for the given search query\n   *\n   * The result is a list of suggested modified search queries, derived from the\n   * given search query, each with a relevance score, sorted by descending score.\n   *\n   * By default, it uses the same options used for search, except that by\n   * default it performs prefix search on the last term of the query, and\n   * combine terms with `'AND'` (requiring all query terms to match). Custom\n   * options can be passed as a second argument. Defaults can be changed upon\n   * calling the {@link MiniSearch} constructor, by passing a\n   * `autoSuggestOptions` option.\n   *\n   * ### Basic usage:\n   *\n   * ```javascript\n   * // Get suggestions for 'neuro':\n   * miniSearch.autoSuggest('neuro')\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n   * ```\n   *\n   * ### Multiple words:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar':\n   * miniSearch.autoSuggest('zen ar')\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * ### Fuzzy suggestions:\n   *\n   * ```javascript\n   * // Correct spelling mistakes using fuzzy search:\n   * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n   * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n   * ```\n   *\n   * ### Filtering:\n   *\n   * ```javascript\n   * // Get suggestions for 'zen ar', but only within the 'fiction' category\n   * // (assuming that 'category' is a stored field):\n   * miniSearch.autoSuggest('zen ar', {\n   *   filter: (result) => result.category === 'fiction'\n   * })\n   * // => [\n   * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n   * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n   * // ]\n   * ```\n   *\n   * @param queryString  Query string to be expanded into suggestions\n   * @param options  Search options. The supported options and default values\n   * are the same as for the {@link MiniSearch#search} method, except that by\n   * default prefix search is performed on the last term in the query, and terms\n   * are combined with `'AND'`.\n   * @return  A sorted array of suggestions sorted by relevance score.\n   */\n  autoSuggest (queryString: string, options: SearchOptions = {}): Suggestion[] {\n    options = { ...this._options.autoSuggestOptions, ...options }\n\n    const suggestions: Map<string, Omit<Suggestion, 'suggestion'> & { count: number }> = new Map()\n\n    for (const { score, terms } of this.search(queryString, options)) {\n      const phrase = terms.join(' ')\n      const suggestion = suggestions.get(phrase)\n      if (suggestion != null) {\n        suggestion.score += score\n        suggestion.count += 1\n      } else {\n        suggestions.set(phrase, { score, terms, count: 1 })\n      }\n    }\n\n    const results = []\n    for (const [suggestion, { score, terms, count }] of suggestions) {\n      results.push({ suggestion, terms, score: score / count })\n    }\n\n    results.sort(byScore)\n    return results\n  }\n\n  /**\n   * Total number of documents available to search\n   */\n  get documentCount (): number {\n    return this._documentCount\n  }\n\n  /**\n   * Number of terms in the index\n   */\n  get termCount (): number {\n    return this._index.size\n  }\n\n  /**\n   * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n   * and instantiates a MiniSearch instance. It should be given the same options\n   * originally used when serializing the index.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // If the index was serialized with:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   *\n   * const json = JSON.stringify(miniSearch)\n   * // It can later be deserialized like this:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return An instance of MiniSearch deserialized from the given JSON.\n   */\n  static loadJSON<T = any> (json: string, options: Options<T>): MiniSearch<T> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJS(JSON.parse(json), options)\n  }\n\n  /**\n   * Async equivalent of {@link MiniSearch.loadJSON}\n   *\n   * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n   * a promise, and loads the index in batches, leaving pauses between them to avoid\n   * blocking the main thread. It tends to be slower than the synchronous\n   * version, but does not block the main thread, so it can be a better choice\n   * when deserializing very large indexes.\n   *\n   * @param json  JSON-serialized index\n   * @param options  configuration options, same as the constructor\n   * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n   */\n  static async loadJSONAsync<T = any> (json: string, options: Options<T>): Promise<MiniSearch<T>> {\n    if (options == null) {\n      throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index')\n    }\n    return this.loadJSAsync(JSON.parse(json), options)\n  }\n\n  /**\n   * Returns the default value of an option. It will throw an error if no option\n   * with the given name exists.\n   *\n   * @param optionName  Name of the option\n   * @return The default value of the given option\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Get default tokenizer\n   * MiniSearch.getDefault('tokenize')\n   *\n   * // Get default term processor\n   * MiniSearch.getDefault('processTerm')\n   *\n   * // Unknown options will throw an error\n   * MiniSearch.getDefault('notExisting')\n   * // => throws 'MiniSearch: unknown option \"notExisting\"'\n   * ```\n   */\n  static getDefault (optionName: string): any {\n    if (defaultOptions.hasOwnProperty(optionName)) {\n      return getOwnProperty(defaultOptions, optionName)\n    } else {\n      throw new Error(`MiniSearch: unknown option \"${optionName}\"`)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  static loadJS<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = objectToNumericMap(documentIds)\n    miniSearch._fieldLength = objectToNumericMap(fieldLength)\n    miniSearch._storedFields = objectToNumericMap(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry) as DocumentTermFreqs)\n      }\n\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  static async loadJSAsync<T = any> (js: AsPlainObject, options: Options<T>): Promise<MiniSearch<T>> {\n    const {\n      index,\n      documentIds,\n      fieldLength,\n      storedFields,\n      serializationVersion\n    } = js\n\n    const miniSearch = this.instantiateMiniSearch(js, options)\n\n    miniSearch._documentIds = await objectToNumericMapAsync(documentIds)\n    miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength)\n    miniSearch._storedFields = await objectToNumericMapAsync(storedFields)\n\n    for (const [shortId, id] of miniSearch._documentIds) {\n      miniSearch._idToShortId.set(id, shortId)\n    }\n\n    let count = 0\n    for (const [term, data] of index) {\n      const dataMap = new Map() as FieldTermData\n\n      for (const fieldId of Object.keys(data)) {\n        let indexEntry = data[fieldId]\n\n        // Version 1 used to nest the index entry inside a field called ds\n        if (serializationVersion === 1) {\n          indexEntry = indexEntry.ds as unknown as SerializedIndexEntry\n        }\n\n        dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry) as DocumentTermFreqs)\n      }\n\n      if (++count % 1000 === 0) await wait(0)\n      miniSearch._index.set(term, dataMap)\n    }\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private static instantiateMiniSearch<T = any> (js: AsPlainObject, options: Options<T>): MiniSearch<T> {\n    const {\n      documentCount,\n      nextId,\n      fieldIds,\n      averageFieldLength,\n      dirtCount,\n      serializationVersion\n    } = js\n\n    if (serializationVersion !== 1 && serializationVersion !== 2) {\n      throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version')\n    }\n\n    const miniSearch = new MiniSearch(options)\n\n    miniSearch._documentCount = documentCount\n    miniSearch._nextId = nextId\n    miniSearch._idToShortId = new Map<any, number>()\n    miniSearch._fieldIds = fieldIds\n    miniSearch._avgFieldLength = averageFieldLength\n    miniSearch._dirtCount = dirtCount || 0\n    miniSearch._index = new SearchableMap()\n\n    return miniSearch\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuery (query: Query, searchOptions: SearchOptions = {}): RawResult {\n    if (query === MiniSearch.wildcard) {\n      return this.executeWildcardQuery(searchOptions)\n    }\n\n    if (typeof query !== 'string') {\n      const options = { ...searchOptions, ...query, queries: undefined }\n      const results = query.queries.map((subquery) => this.executeQuery(subquery, options))\n      return this.combineResults(results, options.combineWith)\n    }\n\n    const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options\n    const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions }\n    const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options\n    const terms = searchTokenize(query)\n      .flatMap((term: string) => searchProcessTerm(term))\n      .filter((term) => !!term) as string[]\n    const queries: QuerySpec[] = terms.map(termToQuerySpec(options))\n    const results = queries.map(query => this.executeQuerySpec(query, options))\n\n    return this.combineResults(results, options.combineWith)\n  }\n\n  /**\n   * @ignore\n   */\n  private executeQuerySpec (query: QuerySpec, searchOptions: SearchOptions): RawResult {\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    const boosts = (options.fields || this._options.fields).reduce((boosts, field) =>\n      ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {})\n\n    const {\n      boostDocument,\n      weights,\n      maxFuzzy,\n      bm25: bm25params\n    } = options\n\n    const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights }\n\n    const data = this._index.get(query.term)\n    const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params)\n\n    let prefixMatches\n    let fuzzyMatches\n\n    if (query.prefix) {\n      prefixMatches = this._index.atPrefix(query.term)\n    }\n\n    if (query.fuzzy) {\n      const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy\n      const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy\n      if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance)\n    }\n\n    if (prefixMatches) {\n      for (const [term, data] of prefixMatches) {\n        const distance = term.length - query.term.length\n        if (!distance) { continue } // Skip exact match.\n\n        // Delete the term from fuzzy results (if present) if it is also a\n        // prefix result. This entry will always be scored as a prefix result.\n        fuzzyMatches?.delete(term)\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to prefixWeight.\n        // The rate of change is much lower than that of fuzzy matches to\n        // account for the fact that prefix matches stay more relevant than\n        // fuzzy matches for longer distances.\n        const weight = prefixWeight * term.length / (term.length + 0.3 * distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    if (fuzzyMatches) {\n      for (const term of fuzzyMatches.keys()) {\n        const [data, distance] = fuzzyMatches.get(term)!\n        if (!distance) { continue } // Skip exact match.\n\n        // Weight gradually approaches 0 as distance goes to infinity, with the\n        // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n        const weight = fuzzyWeight * term.length / (term.length + distance)\n        this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results)\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private executeWildcardQuery (searchOptions: SearchOptions): RawResult {\n    const results = new Map() as RawResult\n    const options: SearchOptionsWithDefaults = { ...this._options.searchOptions, ...searchOptions }\n\n    for (const [shortId, id] of this._documentIds) {\n      const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1\n      results.set(shortId, {\n        score,\n        terms: [],\n        match: {}\n      })\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private combineResults (results: RawResult[], combineWith: CombinationOperator = OR): RawResult {\n    if (results.length === 0) { return new Map() }\n    const operator = combineWith.toLowerCase()\n    const combinator = (combinators as Record<string, CombinatorFunction>)[operator]\n\n    if (!combinator) {\n      throw new Error(`Invalid combination operator: ${combineWith}`)\n    }\n\n    return results.reduce(combinator) || new Map()\n  }\n\n  /**\n   * Allows serialization of the index to JSON, to possibly store it and later\n   * deserialize it with {@link MiniSearch.loadJSON}.\n   *\n   * Normally one does not directly call this method, but rather call the\n   * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n   * instance, and JavaScript will internally call this method. Upon\n   * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n   * options used to create the original instance that was serialized.\n   *\n   * ### Usage:\n   *\n   * ```javascript\n   * // Serialize the index:\n   * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n   * miniSearch.addAll(documents)\n   * const json = JSON.stringify(miniSearch)\n   *\n   * // Later, to deserialize it:\n   * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n   * ```\n   *\n   * @return A plain-object serializable representation of the search index.\n   */\n  toJSON (): AsPlainObject {\n    const index: [string, { [key: string]: SerializedIndexEntry }][] = []\n\n    for (const [term, fieldIndex] of this._index) {\n      const data: { [key: string]: SerializedIndexEntry } = {}\n\n      for (const [fieldId, freqs] of fieldIndex) {\n        data[fieldId] = Object.fromEntries(freqs)\n      }\n\n      index.push([term, data])\n    }\n\n    return {\n      documentCount: this._documentCount,\n      nextId: this._nextId,\n      documentIds: Object.fromEntries(this._documentIds),\n      fieldIds: this._fieldIds,\n      fieldLength: Object.fromEntries(this._fieldLength),\n      averageFieldLength: this._avgFieldLength,\n      storedFields: Object.fromEntries(this._storedFields),\n      dirtCount: this._dirtCount,\n      index,\n      serializationVersion: 2\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private termResults (\n    sourceTerm: string,\n    derivedTerm: string,\n    termWeight: number,\n    termBoost: number,\n    fieldTermData: FieldTermData | undefined,\n    fieldBoosts: { [field: string]: number },\n    boostDocumentFn: ((id: any, term: string, storedFields?: Record<string, unknown>) => number) | undefined,\n    bm25params: BM25Params,\n    results: RawResult = new Map()\n  ): RawResult {\n    if (fieldTermData == null) return results\n\n    for (const field of Object.keys(fieldBoosts)) {\n      const fieldBoost = fieldBoosts[field]\n      const fieldId = this._fieldIds[field]\n\n      const fieldTermFreqs = fieldTermData.get(fieldId)\n      if (fieldTermFreqs == null) continue\n\n      let matchingFields = fieldTermFreqs.size\n      const avgFieldLength = this._avgFieldLength[fieldId]\n\n      for (const docId of fieldTermFreqs.keys()) {\n        if (!this._documentIds.has(docId)) {\n          this.removeTerm(fieldId, docId, derivedTerm)\n          matchingFields -= 1\n          continue\n        }\n\n        const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1\n        if (!docBoost) continue\n\n        const termFreq = fieldTermFreqs.get(docId)!\n        const fieldLength = this._fieldLength.get(docId)![fieldId]\n\n        // NOTE: The total number of fields is set to the number of documents\n        // `this._documentCount`. It could also make sense to use the number of\n        // documents where the current field is non-blank as a normalization\n        // factor. This will make a difference in scoring if the field is rarely\n        // present. This is currently not supported, and may require further\n        // analysis to see if it is a valid use case.\n        const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params)\n        const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore\n\n        const result = results.get(docId)\n        if (result) {\n          result.score += weightedScore\n          assignUniqueTerm(result.terms, sourceTerm)\n          const match = getOwnProperty(result.match, derivedTerm)\n          if (match) {\n            match.push(field)\n          } else {\n            result.match[derivedTerm] = [field]\n          }\n        } else {\n          results.set(docId, {\n            score: weightedScore,\n            terms: [sourceTerm],\n            match: { [derivedTerm]: [field] }\n          })\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * @ignore\n   */\n  private addTerm (fieldId: number, documentId: number, term: string): void {\n    const indexData = this._index.fetch(term, createMap)\n\n    let fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null) {\n      fieldIndex = new Map()\n      fieldIndex.set(documentId, 1)\n      indexData.set(fieldId, fieldIndex)\n    } else {\n      const docs = fieldIndex.get(documentId)\n      fieldIndex.set(documentId, (docs || 0) + 1)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private removeTerm (fieldId: number, documentId: number, term: string): void {\n    if (!this._index.has(term)) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n      return\n    }\n\n    const indexData = this._index.fetch(term, createMap)\n\n    const fieldIndex = indexData.get(fieldId)\n    if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n      this.warnDocumentChanged(documentId, fieldId, term)\n    } else if (fieldIndex.get(documentId)! <= 1) {\n      if (fieldIndex.size <= 1) {\n        indexData.delete(fieldId)\n      } else {\n        fieldIndex.delete(documentId)\n      }\n    } else {\n      fieldIndex.set(documentId, fieldIndex.get(documentId)! - 1)\n    }\n\n    if (this._index.get(term)!.size === 0) {\n      this._index.delete(term)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private warnDocumentChanged (shortDocumentId: number, fieldId: number, term: string): void {\n    for (const fieldName of Object.keys(this._fieldIds)) {\n      if (this._fieldIds[fieldName] === fieldId) {\n        this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict')\n        return\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addDocumentId (documentId: any): number {\n    const shortDocumentId = this._nextId\n    this._idToShortId.set(documentId, shortDocumentId)\n    this._documentIds.set(shortDocumentId, documentId)\n    this._documentCount += 1\n    this._nextId += 1\n    return shortDocumentId\n  }\n\n  /**\n   * @ignore\n   */\n  private addFields (fields: string[]): void {\n    for (let i = 0; i < fields.length; i++) {\n      this._fieldIds[fields[i]] = i\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private addFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    let fieldLengths = this._fieldLength.get(documentId)\n    if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = [])\n    fieldLengths[fieldId] = length\n\n    const averageFieldLength = this._avgFieldLength[fieldId] || 0\n    const totalFieldLength = (averageFieldLength * count) + length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count + 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private removeFieldLength (documentId: number, fieldId: number, count: number, length: number): void {\n    if (count === 1) {\n      this._avgFieldLength[fieldId] = 0\n      return\n    }\n    const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length\n    this._avgFieldLength[fieldId] = totalFieldLength / (count - 1)\n  }\n\n  /**\n   * @ignore\n   */\n  private saveStoredFields (documentId: number, doc: T): void {\n    const { storeFields, extractField } = this._options\n    if (storeFields == null || storeFields.length === 0) { return }\n\n    let documentFields = this._storedFields.get(documentId)\n    if (documentFields == null) this._storedFields.set(documentId, documentFields = {})\n\n    for (const fieldName of storeFields) {\n      const fieldValue = extractField(doc, fieldName)\n      if (fieldValue !== undefined) documentFields[fieldName] = fieldValue\n    }\n  }\n}\n\nconst getOwnProperty = (object: any, property: string) =>\n  Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n\ntype CombinatorFunction = (a: RawResult, b: RawResult) => RawResult\n\nconst combinators: Record<LowercaseCombinationOperator, CombinatorFunction> = {\n  [OR]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) {\n        a.set(docId, b.get(docId)!)\n      } else {\n        const { score, terms, match } = b.get(docId)!\n        existing.score = existing.score + score\n        existing.match = Object.assign(existing.match, match)\n        assignUniqueTerms(existing.terms, terms)\n      }\n    }\n\n    return a\n  },\n  [AND]: (a: RawResult, b: RawResult) => {\n    const combined = new Map()\n\n    for (const docId of b.keys()) {\n      const existing = a.get(docId)\n      if (existing == null) continue\n\n      const { score, terms, match } = b.get(docId)!\n      assignUniqueTerms(existing.terms, terms)\n      combined.set(docId, {\n        score: existing.score + score,\n        terms: existing.terms,\n        match: Object.assign(existing.match, match)\n      })\n    }\n\n    return combined\n  },\n  [AND_NOT]: (a: RawResult, b: RawResult) => {\n    for (const docId of b.keys()) a.delete(docId)\n    return a\n  }\n}\n\n/**\n * Parameters of the BM25+ scoring algorithm. Customizing these is almost never\n * necessary, and finetuning them requires an understanding of the BM25 scoring\n * model.\n *\n * Some information about BM25 (and BM25+) can be found at these links:\n *\n *   - https://en.wikipedia.org/wiki/Okapi_BM25\n *   - https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/\n */\nexport type BM25Params = {\n  /** Term frequency saturation point.\n   *\n   * Recommended values are between `1.2` and `2`. Higher values increase the\n   * difference in score between documents with higher and lower term\n   * frequencies. Setting this to `0` or a negative value is invalid. Defaults\n   * to `1.2`\n   */\n  k: number,\n\n  /**\n   * Length normalization impact.\n   *\n   * Recommended values are around `0.75`. Higher values increase the weight\n   * that field length has on scoring. Setting this to `0` (not recommended)\n   * means that the field length has no effect on scoring. Negative values are\n   * invalid. Defaults to `0.7`.\n   */\n  b: number,\n\n  /**\n   * BM25+ frequency normalization lower bound (usually called ).\n   *\n   * Recommended values are between `0.5` and `1`. Increasing this parameter\n   * increases the minimum relevance of one occurrence of a search term\n   * regardless of its (possibly very long) field length. Negative values are\n   * invalid. Defaults to `0.5`.\n   */\n  d: number\n}\n\nconst defaultBM25params: BM25Params = { k: 1.2, b: 0.7, d: 0.5 }\n\nconst calcBM25Score = (\n  termFreq: number,\n  matchingCount: number,\n  totalCount: number,\n  fieldLength: number,\n  avgFieldLength: number,\n  bm25params: BM25Params\n): number => {\n  const { k, b, d } = bm25params\n  const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)))\n}\n\nconst termToQuerySpec = (options: SearchOptions) => (term: string, i: number, terms: string[]): QuerySpec => {\n  const fuzzy = (typeof options.fuzzy === 'function')\n    ? options.fuzzy(term, i, terms)\n    : (options.fuzzy || false)\n  const prefix = (typeof options.prefix === 'function')\n    ? options.prefix(term, i, terms)\n    : (options.prefix === true)\n  const termBoost = (typeof options.boostTerm === 'function')\n    ? options.boostTerm(term, i, terms)\n    : 1\n  return { term, fuzzy, prefix, termBoost }\n}\n\nconst defaultOptions = {\n  idField: 'id',\n  extractField: (document: any, fieldName: string) => document[fieldName],\n  stringifyField: (fieldValue: any, fieldName: string) => fieldValue.toString(),\n  tokenize: (text: string) => text.split(SPACE_OR_PUNCTUATION),\n  processTerm: (term: string) => term.toLowerCase(),\n  fields: undefined,\n  searchOptions: undefined,\n  storeFields: [],\n  logger: (level: LogLevel, message: string): void => {\n    if (typeof console?.[level] === 'function') console[level](message)\n  },\n  autoVacuum: true\n}\n\nconst defaultSearchOptions = {\n  combineWith: OR,\n  prefix: false,\n  fuzzy: false,\n  maxFuzzy: 6,\n  boost: {},\n  weights: { fuzzy: 0.45, prefix: 0.375 },\n  bm25: defaultBM25params\n}\n\nconst defaultAutoSuggestOptions = {\n  combineWith: AND,\n  prefix: (term: string, i: number, terms: string[]): boolean =>\n    i === terms.length - 1\n}\n\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 }\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 }\n\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions }\n\nconst assignUniqueTerm = (target: string[], term: string): void => {\n  // Avoid adding duplicate terms.\n  if (!target.includes(term)) target.push(term)\n}\n\nconst assignUniqueTerms = (target: string[], source: readonly string[]): void => {\n  for (const term of source) {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term)) target.push(term)\n  }\n}\n\ntype Scored = { score: number }\nconst byScore = ({ score: a }: Scored, { score: b }: Scored) => b - a\n\nconst createMap = () => new Map()\n\ninterface SerializedIndexEntry {\n  [key: string]: number\n}\n\nconst objectToNumericMap = <T>(object: { [key: string]: T }): Map<number, T> => {\n  const map = new Map()\n\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n  }\n\n  return map\n}\n\nconst objectToNumericMapAsync = async <T>(object: { [key: string]: T }): Promise<Map<number, T>> => {\n  const map = new Map()\n\n  let count = 0\n  for (const key of Object.keys(object)) {\n    map.set(parseInt(key, 10), object[key])\n    if (++count % 1000 === 0) {\n      await wait(0)\n    }\n  }\n\n  return map\n}\n\nconst wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u\n","import uniqBy from 'lodash.uniqby';\nimport MiniSearch, { SearchResult } from 'minisearch'\nimport Meme from './Meme'\n\nlet index: MiniSearch\nlet descIndex: MiniSearch | null = null\nlet criteria = ''\n\nconst CACHE_NAME = 'paddedmemes-v1'\nconst ASSETS_URL = process.env.REACT_APP_ASSETS_URL\n\nasync function fetchWithCache(name: string, versionName: string): Promise<string> {\n  const cache = await caches.open(CACHE_NAME)\n  const versionUrl = `${ASSETS_URL}/${versionName}`\n  const dataUrl = `${ASSETS_URL}/${name}`\n\n  // Fetch the small version file (always fresh, no-cache)\n  const versionRes = await fetch(versionUrl)\n  const remoteVersion = versionRes.ok ? await versionRes.json() : null\n\n  // Try to load from cache\n  if (remoteVersion) {\n    const cachedVersion = await cache.match(versionUrl)\n    if (cachedVersion) {\n      const localVersion = await cachedVersion.json()\n      if (localVersion.hash === remoteVersion.hash) {\n        const cachedData = await cache.match(dataUrl)\n        if (cachedData) {\n          return cachedData.text()\n        }\n      }\n    }\n  }\n\n  // Cache miss or version mismatch  fetch fresh data\n  const dataRes = await fetch(dataUrl)\n  const ds = new (globalThis as any).DecompressionStream('gzip')\n  const decompressed = dataRes.body!.pipeThrough(ds)\n  const text = await new Response(decompressed).text()\n\n  // Store both in cache\n  await cache.put(dataUrl, new Response(text))\n  if (remoteVersion) {\n    await cache.put(versionUrl, new Response(JSON.stringify(remoteVersion)))\n  }\n\n  return text\n}\n\nconst doSearch = () => {\n  if (!index) return\n  const c = criteria.split(' ').filter((x) => x.length >= 3).join(' ')\n  if (c === '') {\n    global.self.postMessage(['setDidSearch', false])\n    global.self.postMessage(['setSearchResults', []])\n    return\n  }\n  const textResults = index.search(criteria)\n  const scoreMap = new Map<string, SearchResult>()\n  for (const r of textResults) {\n    scoreMap.set(r.photo, { ...r, ...getStoredFields(r.photo) })\n  }\n\n  if (descIndex) {\n    const descResults = descIndex.search(criteria)\n    // Merge: combine scores for items found in both, union otherwise\n    for (const r of descResults) {\n      const existing = scoreMap.get(r.photo)\n      if (existing) {\n        existing.score += r.score\n      } else {\n        scoreMap.set(r.photo, { ...r, ...getStoredFields(r.photo) })\n      }\n    }\n  }\n  const allResults = Array.from(scoreMap.values()).sort((a, b) => b.score - a.score)\n  const filtered = allResults.filter((tag, idx, array) => array.findIndex((doc: SearchResult) => tag.photo === doc.photo) === idx)\n  global.self.postMessage(['setDidSearch', true])\n  global.self.postMessage(['setSearchResults', filtered.slice(0, 40)])\n}\n\nlet storedFieldsMap: Record<string, Meme> = {}\n\nfunction getStoredFields(photo: string): Partial<Meme> {\n  return storedFieldsMap[photo] || {}\n}\n\nexport async function init () {\n  const dbPromise = fetchWithCache('db.json', 'db.version.json')\n  const descPromise = fetchWithCache('descriptions.json', 'descriptions.version.json')\n    .catch(() => null)\n\n  const [data, descData] = await Promise.all([dbPromise, descPromise])\n\n  // minisearch configuration must match datamaker's\n  index = MiniSearch.loadJSON(data, {\n    idField: 'photo',\n    fields: ['text'],\n    storeFields: ['date_unixtime', 'photo', 'width', 'height', 'reactions', 'chat_id', 'message_id'],\n    searchOptions: {\n      combineWith: 'AND',\n      prefix: true\n    }\n  })\n\n  const jsonData = JSON.parse(data)\n  const storedFields: Record<string, Meme> = jsonData.storedFields\n  // Build lookup for merging description-only results with meme metadata\n  storedFieldsMap = {}\n  for (const [, doc] of Object.entries(storedFields)) {\n    storedFieldsMap[doc.photo] = doc\n  }\n\n  if (descData) {\n    descIndex = MiniSearch.loadJSON(descData, {\n      idField: 'photo',\n      fields: ['description'],\n      storeFields: ['photo', 'description_en', 'description_es'],\n      searchOptions: {\n        combineWith: 'AND',\n        prefix: true\n      }\n    })\n  }\n\n  const defaultResults = uniqBy(Object.values(storedFields), (f) => f.photo)\n    .sort((a, b) => - parseInt(a.date_unixtime, 10) + parseInt(b.date_unixtime, 10))\n    .slice(0, 40)\n  global.self.postMessage(['setReady', true])\n  global.self.postMessage(['setDefaultResults', defaultResults])\n\n  doSearch()\n}\n\nexport async function search (searchCriteria: string) {\n  criteria = searchCriteria\n  doSearch()\n}\n\nexport async function autoSuggest (query: string) {\n  if (!index || query.trim().length < 2) {\n    global.self.postMessage(['setSuggestions', []])\n    return\n  }\n  const opts = { combineWith: 'AND' as const, prefix: true }\n  const textSuggestions = index.autoSuggest(query, opts)\n  let allSuggestions = textSuggestions\n  if (descIndex) {\n    const descSuggestions = descIndex.autoSuggest(query, opts)\n    const seen = new Set(textSuggestions.map(s => s.suggestion))\n    for (const s of descSuggestions) {\n      if (!seen.has(s.suggestion)) {\n        allSuggestions.push(s)\n      }\n    }\n    allSuggestions.sort((a, b) => b.score - a.score)\n  }\n  global.self.postMessage(['setSuggestions', allSuggestions.slice(0, 5).map(s => s.suggestion)])\n}\n"],"names":["HASH_UNDEFINED","INFINITY","MAX_SAFE_INTEGER","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","reIsUint","typedArrayTags","freeGlobal","global","Object","freeSelf","self","root","Function","freeExports","exports","nodeType","freeModule","module","freeProcess","process","nodeUtil","binding","e","nodeIsTypedArray","isTypedArray","arrayIncludes","array","value","length","fromIndex","predicate","fromRight","index","baseFindIndex","baseIsNaN","baseIndexOf","arrayIncludesWith","comparator","arraySome","cacheHas","cache","key","has","isHostObject","result","toString","mapToArray","map","Array","size","forEach","setToArray","set","func","transform","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","uid","exec","keys","IE_PROTO","funcToString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Symbol","Uint8Array","propertyIsEnumerable","splice","nativeKeys","arg","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","undefined","symbolValueOf","valueOf","symbolToString","Hash","entries","this","clear","entry","ListCache","MapCache","SetCache","values","__data__","add","Stack","arrayLikeKeys","inherited","isArray","isArguments","n","iteratee","baseTimes","String","skipIndexes","isIndex","push","assocIndexOf","eq","baseGet","object","path","isKey","castPath","toKey","baseHasIn","baseIsEqual","other","customizer","bitmask","stack","isObject","isObjectLike","equalFunc","objIsArr","othIsArr","objTag","othTag","getTag","objIsObj","othIsObj","isSameTag","equalArrays","tag","byteLength","byteOffset","buffer","name","message","convert","isPartial","stacked","get","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","objLength","othProps","othLength","skipCtor","objValue","othValue","compared","objCtor","constructor","othCtor","equalObjects","baseIsEqualDeep","baseIsNative","isMasked","isFunction","test","baseIteratee","identity","srcValue","isStrictComparable","matchesStrictComparable","defaultValue","hasFunc","isLength","hasPath","hasIn","UNORDERED_COMPARE_FLAG","baseMatchesProperty","source","matchData","getMatchData","noCustomizer","data","baseIsMatch","baseMatches","basePropertyDeep","property","baseKeys","Ctor","proto","isPrototype","stringToPath","pop","getMapData","pairs","LARGE_ARRAY_SIZE","createSet","arrLength","seen","arrValue","othIndex","type","isKeyable","getValue","isSymbol","ArrayBuffer","resolve","ctorString","memoize","string","baseToString","match","number","quote","resolver","TypeError","memoized","args","arguments","apply","Cache","isArrayLike","isArrayLikeObject","baseUnary","includes","isCommon","outer","computed","seenIndex","baseUniq","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","getter","__esModule","d","a","definition","o","defineProperty","enumerable","g","globalThis","window","obj","prop","nmd","paths","children","_typeof","iterator","toPropertyKey","t","i","r","toPrimitive","Number","_defineProperty","configurable","writable","ownKeys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","_objectSpread2","getOwnPropertyDescriptors","defineProperties","KEYS","VALUES","LEAF","TreeIterator","node","_tree","from","_type","_path","next","dive","backtrack","done","last$1","child","_prefix","_ref","join","recurse","query","maxDistance","results","matrix","m","prefix","offset","distance","pos","char","thisRowOffset","prevRowOffset","minDistance","jmin","Math","max","jmax","min","j","different","rpl","del","ins","dist","SearchableMap","tree","_size","atPrefix","startsWith","Error","trackDown","slice","parentNode","last","k","delete","remove","fn","fuzzyGet","maxEditDistance","fuzzySearch","fill","lookup","createPath","iter","update","fetch","initial","fromObject","keyLength","len","intermediate","cleanup","merge","nodeKey","OR","AND","AND_NOT","MiniSearch","options","fields","autoVacuum","defaultAutoVacuumOptions","_options","_objectSpread","defaultOptions","searchOptions","defaultSearchOptions","autoSuggestOptions","defaultAutoSuggestOptions","_index","_documentCount","_documentIds","_idToShortId","_fieldIds","_fieldLength","_avgFieldLength","_nextId","_storedFields","_dirtCount","_currentVacuum","_enqueuedVacuum","_enqueuedVacuumConditions","defaultVacuumConditions","addFields","document","extractField","stringifyField","tokenize","processTerm","idField","concat","shortDocumentId","addDocumentId","saveStoredFields","field","fieldValue","tokens","fieldId","uniqueTerms","addFieldLength","term","processedTerm","addTerm","addAll","documents","addAllAsync","chunkSize","acc","chunk","promise","reduce","_ref2","then","setTimeout","shortId","removeFieldLength","removeTerm","removeAll","discard","fieldLength","maybeAutoVacuum","minDirtFactor","minDirtCount","batchSize","batchWait","conditionalVacuum","discardAll","ids","updatedDocument","vacuum","conditions","performVacuuming","vacuumConditionsMet","initialDirtCount","defaultVacuumOptions","fieldsData","fieldIndex","dirtCount","dirtFactor","isVacuuming","getStoredFields","search","globalSearchOptions","searchOptionsWithDefaults","rawResults","executeQuery","docId","score","terms","quality","queryTerms","assign","wildcard","boostDocument","sort","byScore","autoSuggest","queryString","suggestions","phrase","suggestion","count","documentCount","termCount","loadJSON","json","loadJS","JSON","parse","loadJSONAsync","loadJSAsync","getDefault","optionName","getOwnProperty","js","documentIds","storedFields","serializationVersion","miniSearch","instantiateMiniSearch","objectToNumericMap","dataMap","indexEntry","ds","parseInt","objectToNumericMapAsync","wait","nextId","fieldIds","averageFieldLength","executeWildcardQuery","queries","subquery","combineResults","combineWith","searchTokenize","searchProcessTerm","flatMap","termToQuerySpec","executeQuerySpec","boosts","boost","weights","maxFuzzy","bm25","bm25params","fuzzy","fuzzyWeight","prefixWeight","termResults","termBoost","prefixMatches","fuzzyMatches","round","weight","operator","toLowerCase","combinator","combinators","toJSON","freqs","fromEntries","sourceTerm","derivedTerm","termWeight","fieldTermData","fieldBoosts","boostDocumentFn","fieldBoost","fieldTermFreqs","matchingFields","avgFieldLength","docBoost","termFreq","weightedScore","calcBM25Score","assignUniqueTerm","documentId","indexData","createMap","docs","warnDocumentChanged","fieldName","logger","fieldLengths","totalFieldLength","doc","storeFields","documentFields","b","existing","assignUniqueTerms","combined","matchingCount","totalCount","log","boostTerm","text","split","SPACE_OR_PUNCTUATION","level","console","target","_ref3","_ref4","async","ms","descIndex","criteria","CACHE_NAME","ASSETS_URL","fetchWithCache","versionName","caches","open","versionUrl","dataUrl","versionRes","remoteVersion","ok","cachedVersion","hash","cachedData","dataRes","DecompressionStream","decompressed","body","pipeThrough","Response","put","stringify","doSearch","x","postMessage","textResults","scoreMap","photo","descResults","filtered","idx","findIndex","storedFieldsMap","init","dbPromise","descPromise","catch","descData","all","defaultResults","uniqBy","f","date_unixtime","searchCriteria","trim","opts","textSuggestions","allSuggestions","descSuggestions","s"],"sourceRoot":""}